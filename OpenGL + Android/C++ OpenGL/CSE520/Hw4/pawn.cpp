/*  sweep1.cpp
*  Construct surfaces of revolution using wireframe but have not considered lighting.
*  Surface is generated by revolving a curve around x-axis.     
*  A curve f(x) is generated by polynomial interpolation from some control points
*  or by some interested functions.
*
*  @Author: T.L. Yu, Fall 2008 
*/
#include <GL/glut.h>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <stdlib.h>

using namespace std;

const double PI = 3.14159265389;
int Npoints = 8; //27 8
int anglex= 0, angley = 0, anglez = 0;          //rotation angles
int window;

//control points
GLfloat ctrlpoints[8][3] = {
  {0.0, 0.0, 0.0}, {0.25, 0.5, 0.0}, {0.5, 0.7, 0.0}, { 1.0, 0.5, 0.0}, 
  {2.0, 0.7, 0.0}, {2.5, 1.2, 0.0}, {3.0, 1.8, 0.0}, {3.5, 1.7, 0.0}
};

/*
GLfloat ctrlpoints[27][3] = {
{4.38,0.00, 0},{4.22,0.50, 0},{3.98,0.72, 0},{3.62,0.80, 0},{3.24,0.66, 0},
{3.10,0.56, 0},{2.92,0.80, 0},{2.76,0.88, 0},{2.58,0.74, 0},{2.48,0.44, 0},
{2.10,0.48, 0},{1.74,0.60, 0},{1.54,0.66, 0},{1.44,0.90, 0},{1.10,1.04, 0},
{0.90,1.18, 0},{0.76,1.38, 0},{0.68,1.48, 0},{0.62,1.48, 0},{0.58,1.44, 0},
{0.52,1.36, 0},{0.44,1.38, 0},{0.30,1.46, 0},{0.28,1.54, 0},{0.22,1.50, 0},
{0.10,1.50, 0},{0.00,1.50, 0}
};
*/


void init(void) {
   glClearColor(1.0, 1.0, 1.0, 1.0);
   glPolygonMode( GL_FRONT, GL_LINE ) ;
   glPolygonMode( GL_BACK,  GL_LINE ) ;
   glShadeModel(GL_FLAT);
}


//polynomial interpretation for N points
float polyint ( float  points[][3], float x, int N )
{
  float y;

  float num = 1.0, den = 1.0;
  float sum = 0.0;

  for ( int i = 0; i < N; ++i ) {
    num = den = 1.0;
    for ( int j = 0; j < N; ++j ) {
      if ( j == i ) continue;

      num = num * ( x - points[j][0] );     //x - xj
    }
    for ( int j = 0; j < N; ++j ) {
      if ( j == i ) continue;
      den = den * ( points[i][0] - points[j][0] );  //xi - xj
    }
    sum += num / den * points[i][1];
  }
  y = sum;

  return y;
}

float aLine ( float x )
{
  return x + 2.5;
}

void display(void)
{
   int i, j;
   float x, y, z, r;        //current coordinates
   float x1, y1, z1, r1;      //next coordinates
   float theta;

   glClear(GL_COLOR_BUFFER_BIT);
   glColor3f(0.0, 1.0, 1.0);
   const float startx = 0.0, endx = 3.5;
   const int nx = 20;       //number of slices along x-direction
   const int ntheta = 128;     //number of angular slices
   const float dx = (endx - startx) / nx; //x step size
   const float dtheta = 2*PI / ntheta;    //angular step size

   x = startx;
   //r = aLine ( x );
   r = polyint( ctrlpoints, x, Npoints);
   glPushMatrix();
   glRotatef( anglex, 1.0, 0.0, 0.0);         //rotate the object about x-axis
   glRotatef( angley, 0.0, 1.0, 0.0);           //rotate about y-axis   
   glRotatef( anglez, 0.0, 0.0, 1.0);   //rotate about z-axis
  
   for ( i = 0; i < nx; ++i ) {     //step through x
      theta = 0;
      x1 = x + dx;        //next x
      //r1 = aLine ( x1 );      //next f(x)
      r1 = polyint( ctrlpoints, x1, Npoints);   //next f(x)
      //draw the surface composed of quadrilaterals by sweeping theta
      glBegin( GL_QUAD_STRIP );
  for ( j = 0; j <= ntheta; ++j ) {
    theta += dtheta;
    double cosa = cos( theta );
    double sina = sin ( theta );
    y = r * cosa;  y1 = r1 * cosa;  //current and next y
    z = r * sina;  z1 = r1 * sina;  //current and next z
   
    //edge from point at x to point at next x
    glVertex3f (x, y, z);
    glVertex3f (x1, y1, z1);
    
    //forms quad with next pair of points with incremented theta value  
  }         
      glEnd();
      x = x1;
      r = r1; 
   } //for i

   /* The following code displays the control points as dots. */
   glPointSize(5.0);
   glColor3f(1.0, 0.0, 1.0);
   glBegin(GL_POINTS);
      for (i = 0; i < Npoints; i++) 
         glVertex3fv(&ctrlpoints[i][0]);
   glEnd();
   glPopMatrix();
   glFlush();
}


void reshape(int w, int h)
{
   glViewport(0, 0, (GLsizei) w, (GLsizei) h);
   glMatrixMode(GL_PROJECTION);
   glLoadIdentity();
   if (w <= h)
      glOrtho(-5.0, 5.0, -5.0*(GLfloat)h/(GLfloat)w, 
               5.0*(GLfloat)h/(GLfloat)w, -5.0, 5.0);
   else
      glOrtho(-5.0*(GLfloat)w/(GLfloat)h, 
               5.0*(GLfloat)w/(GLfloat)h, -5.0, 5.0, -5.0, 5.0);
   glMatrixMode(GL_MODELVIEW);
   glLoadIdentity();
}


void keyboard(unsigned char key, int x, int y)
{
  switch(key) {
    case 'x':
      anglex = ( anglex + 3 ) % 360;
      break;
    case 'X':
      anglex = ( anglex - 3 ) % 360;
      break;
    case 'y':
      angley = ( angley + 3 ) % 360;
      break;
    case 'Y':
      angley = ( angley - 3 ) % 360;
      break;
    case 'z':
      anglez = ( anglez + 3 ) % 360;
      break;
    case 'Z':
      anglez = ( anglez - 3 ) % 360;
      break;
    case 'r':         //reset
      anglez = angley = anglex = 0;
      glLoadIdentity();
      break;
    case 27: /* escape */
        glutDestroyWindow(window);
        exit(0);
  }
  glutPostRedisplay();
}

int main(int argc, char** argv)
{
   glutInit(&argc, argv);
   glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);
   glutInitWindowSize (500, 500);
   glutInitWindowPosition (100, 100);
   glutCreateWindow (argv[0]);
   init ();
   glutDisplayFunc(display);
   glutReshapeFunc(reshape);
   glutKeyboardFunc (keyboard);
   glutMainLoop();
   return 0;
}
    